# varmodel2

Ed Baskerville
Updated 16 October 2017

This code is an implementation of a model of malaria var gene evolution within an epidemic simulation.
Malaria strains are represented as unordered sets of var genes, which are in turn composed of abstract loci.
A number of alleles can appear at each locus, and the allelic composition of a gene across loci governs immune dynamics in the host.
Individual hosts are infected by strains, and infections can be transmitted between hosts.
Each infection expresses a single var gene at a time, and the sequence of expressions is explicitly represented in the simulation.
The simulation also includes immigration of new strains into the population, recombination during transmission and during an infection, and mutation.

The simulation is modeled as a sequence of discrete events (state changes) that happen in continuous time.

## Building and running the model

The code is designed to be used with a fresh working directory for each run.

To do an individual run, first set up a parameter file as a simple Python module, following `parameters-example.py`.

The parameter names should match variables defined in `parameters.hpp.template`, and the values should match the appropriate type: e.g., floating-point numbers for `double`; integers for `int64_t` and `uint64_t`; lists for `array`; etc.

String values are passed verbatim, enabling the use of both enumerated types and strings.
Therefore, use

```py
SELECTION_MODE = 'SPECIFIC_IMMUNITY'
```

to specify an enumerated type, but

```py
SAMPLE_DB_FILENAME = '"output_samples.sqlite"'
```

to specify a string, with inner quotation marks.

To build the code with the specified parameters, do:

```sh
path/to/build.py -p params.py -d rundir
```

This will do the following things:

* Generate the file `rundir/generated/parameters.hpp` by inserting values from `params.py`
* Generate `rundir/generated/*Manager.*` files, which contain code to manage objects of different types and save/load them to checkpoint databases
* If all goes well, compile the model into `rundir/bin/varmodel2`.

You can now run the model via:

```sh
cd rundir
./bin/varmodel2
```

You can also write parameter files in JSON format, following the same 
This is most useful for generated parameter files, e.g. for producing replicates or parameter sweeps to be submitted to SLURM.

## Model specification

## History and overview of changes

This code is a new, simpler implementation of the malaria var gene evolution model by Qixin He, in which var genes are composed of loci with varying alleles.
That model was based on a model by Yael Artzy-Randrup, implemented by Ed Baskerville, in which var genes are simply distinguished from each other by identity.

The main changes from the previous implementation are as follows:

* Some details of model behavior have changed (see section below).
* Parameters are compile-time constants instead of being dynamically loaded from JSON at runtime, which added unnecessary complexity to the C++ code.
A Python script is used to generate the `parameters.hpp` constants file from either JSON or from a Python module.
* The abstraction layer for database output was removed.
Output tables (for sampling) are written using raw calls to the SQLite API.
* You can save and load checkpoints&mdash;complete on-disk representations of the simulation state.
The checkpointing code is automatically generated by a Python script that parses C++ data structures.
Checkpoints are SQLite databases following a simple object relational model (ORM) for the simulation state, and are suitable as a basis for more detailed analysis than periodic sampling.
* C++ language features are used only where they clearly make the code better without impairing readability for people with limited familiarity with C++.

## Code generation for parameters and database output

## Debugging and testing

Debugging output is produced via the `PRINT_DEBUG` macro, whose first argument is an integer debugging level.

The `PRINT_DEBUG_LEVEL` parameter controls what debugging output is actually produced.

Note that turning on all debugging output will substantially slow down the simulation, not to mention.
(Because `PRINT_DEBUG_LEVEL` is a compile-time constant, the compiler will eliminate all unused debugging statements from the code.)

Before each simulation, a small set of unit tests are run on parts of the code to ensure they are working correctly.

Additionally, every `VERIFICATION_PERIOD` in simulation time units, data structures are checked for integrity.

## Behavioral changes from previous model

All changes listed here are relative to [VarModel repo commit f66d253](https://github.com/pascualgroup/VarModel/commit/f66d253176960a539db9628c1a7aeaa7fa4ab6f1).

### Elimination of inactive state between gene expressions

There is no longer an "inactive" state between gene expressions.
Instead, state transitions go directly from the liver (waiting) stage to the first expression, then the second expression, and so on.

### Dead code removal

TODO: list unused functionality that was removed

### Bug fix: off-by-one error in ectopic recombination

In the previous version of the code, there was an off-by-one error in choosing the crossover point.

The crossover point was never chosen to be just before the last locus; rather, the farthest along it could be was before the second-to-last locus.
This has been fixed in the new version of the code.

### Bug fix in recombination during transmission

In choosing the two strains to be recombined, the recombination probability was set assuming that a distinct pair of strains would be selected, but in fact the same pair could be selected for recombination.

Now, the code simply chooses two random strains.
If they are the same, no recombination occurs; if they are different, recombination occurs.
