# varmodel2

Ed Baskerville
Updated 16 October 2017

This code is an implementation of a model of malaria var gene evolution within an epidemic simulation.
Malaria strains are represented as unordered sets of var genes, which are in turn composed of abstract loci.
A number of alleles can appear at each locus, and the allelic composition of a gene across loci governs immune dynamics in the host.
Individual hosts are infected by strains, and infections can be transmitted between hosts.
Each infection expresses a single var gene at a time, and the sequence of expressions is explicitly represented in the simulation.
The simulation also includes immigration of new strains into the population, recombination during transmission and during an infection, and mutation.

The simulation is modeled as a sequence of discrete events (state changes) that happen in continuous time.

## History and overview of changes

This code is a new, simpler implementation of the malaria var gene evolution model by Qixin He, in which var genes are composed of loci with varying alleles.
That model was based on a model by Yael Artzy-Randrup, implemented by Ed Baskerville, in which var genes are simply distinguished from each other by identity.

The main changes from the previous implementation are as follows:

* Parameters are compile-time constants instead of being dynamically loaded from JSON at runtime, which added unnecessary complexity to the C++ code.
A Python script is used to generate the `parameters.hpp` constants file from either JSON or from a Python module.
* The abstraction layer for database output was removed.
Output tables (for sampling) are written using raw calls to the SQLite API.
* You can save and load checkpoints&mdash;complete on-disk representations of the simulation state.
The checkpointing code is automatically generated by a Python script that parses C++ data structures.
Checkpoints are SQLite databases following a simple object relational model (ORM) for the simulation state, and are suitable as a basis for more detailed analysis than periodic sampling.
* C++ language features are used only where they clearly make the code better without impairing readability for people with limited familiarity with C++.

## Code generation for parameters and database output

## Parameter format

## Debugging and testing

Debugging output is produced via the `PRINT_DEBUG` macro, whose first argument is an integer debugging level.

The `PRINT_DEBUG_LEVEL` parameter controls what debugging output is actually produced.

Note that turning on all debugging output will substantially slow down the simulation, not to mention.
(Because `PRINT_DEBUG_LEVEL` is a compile-time constant, the compiler will eliminate all unused debugging statements from the code.)

Before each simulation, a small set of unit tests are run on parts of the code to ensure they are working correctly.

Additionally, every `VERIFICATION_PERIOD` in simulation time units, data structures are checked for integrity.

## Behavioral changes from previous model

All changes listed here are relative to [VarModel repo commit f66d253](https://github.com/pascualgroup/VarModel/commit/f66d253176960a539db9628c1a7aeaa7fa4ab6f1).

### Dead code removal

### Bug fixes

Bug fix: same strain cannot be chosen for recombination during transmission


